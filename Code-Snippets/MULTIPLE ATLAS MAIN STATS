--input your node Addresses, leave unused slots like they are and turn unused off by setting to 0 below address input in the nodeactive variables. 

-- input your Atlas node Address here:
set nodeaddress1 to "0x0000000000000000000000000000000000000000"

-- input your Atlas node Address here:
set nodeaddress2 to "0x0000000000000000000000000000000000000000"

-- input your Atlas node Address here:
set nodeaddress3 to "0x0000000000000000000000000000000000000000"

-- input your Atlas node Address here:
set nodeaddress4 to "0x0000000000000000000000000000000000000000"

-- input your Atlas node Address here:
set nodeaddress5 to "0x0000000000000000000000000000000000000000"

-- input your Atlas node Address here:
set nodeaddress6 to "0x0000000000000000000000000000000000000000"


-- set nodes to process information from here:

set nodeactive1 to 1
set nodeactive2 to 0
set nodeactive3 to 0
set nodeactive4 to 0
set nodeactive5 to 0
set nodeactive6 to 0
----------------------

set stake1 to 0
set stake2 to 0
set stake3 to 0
set stake4 to 0
set stake5 to 0
set stake6 to 0

set balance1 to 0.0
set balance2 to 0.0
set balance3 to 0.0
set balance4 to 0.0
set balance5 to 0.0
set balance6 to 0.0

set allbundles1 to 0
set allbundles2 to 0
set allbundles3 to 0
set allbundles4 to 0
set allbundles5 to 0
set allbundles6 to 0

if nodeactive1 is equal to 1 then
	set returnValues to pullAPIdataATLAS(nodeaddress1)
	
	set balance1 to item 1 of returnValues
	set stake1 to item 2 of returnValues
	set stake1 to RemoveFromString("}", stake1)
	set allbundles1 to item 3 of returnValues
end if

if nodeactive2 is equal to 1 then
	set returnValues to pullAPIdataATLAS(nodeaddress2)
	
	set balance2 to item 1 of returnValues
	set stake2 to item 2 of returnValues
	set stake2 to RemoveFromString("}", stake2)
	set allbundles2 to item 3 of returnValues
end if

if nodeactive3 is equal to 1 then
	set returnValues to pullAPIdataATLAS(nodeaddress3)
	
	set balance3 to item 1 of returnValues
	set stake3 to item 2 of returnValues
	set stake3 to RemoveFromString("}", stake3)
	set allbundles3 to item 3 of returnValues
end if

if nodeactive4 is equal to 1 then
	set returnValues to pullAPIdataATLAS(nodeaddress4)
	
	set balance4 to item 1 of returnValues
	set stake4 to item 2 of returnValues
	set stake4 to RemoveFromString("}", stake4)
	set allbundles4 to item 3 of returnValues
end if

if nodeactive5 is equal to 1 then
	set returnValues to pullAPIdataATLAS(nodeaddress5)
	
	set balance5 to item 1 of returnValues
	set stake5 to item 2 of returnValues
	set stake5 to RemoveFromString("}", stake5)
	set allbundles5 to item 3 of returnValues
end if

if nodeactive6 is equal to 1 then
	set returnValues to pullAPIdataATLAS(nodeaddress6)
	
	set balance6 to item 1 of returnValues
	set stake6 to item 2 of returnValues
	set stake6 to RemoveFromString("}", stake6)
	set allbundles6 to item 3 of returnValues
end if

----------------


set stake to stake1 + stake2 + stake3 + stake4 + stake5 + stake6

set allbundles to allbundles1 + allbundles2 + allbundles3 + allbundles4 + allbundles5 + allbundles6

set balance to balance1 + balance2 + balance3 + balance4 + balance5 + balance6
set balance to number_to_string(balance)
set balance to RoundImperialNumberToTwoDecimals(balance)


set unformatedValue to "| " & balance & " AMB | " & allbundles & " Bundles | " & stake & " Stake |"

return RemoveFromString("\"", unformatedValue)


------- functions below -----------------------

---- pull api data ATLAS
on pullAPIdataATLAS(nodeAddress)
	-- get info around particular Atlas node
	set mJson to do shell script "curl -s 'https://explorer-api.ambrosus.com/atlases'"
	set AppleScript's text item delimiters to {nodeAddress}
	set keyNodeList to (every text item in mJson) as list
	set AppleScript's text item delimiters to ""
	
	set listSize to count of keyNodeList
	set page to 1
	-- iterate through pages of 50 nodes to find the right one
	repeat while listSize = 1
		set AppleScript's text item delimiters to {"\"next\":"}
		set keyNodeList to (every text item in mJson) as list
		set AppleScript's text item delimiters to ""
		set pageEnd to item 2 of keyNodeList
		
		set AppleScript's text item delimiters to {","}
		set nextPageIdList to (every text item in pageEnd) as list
		set AppleScript's text item delimiters to ""
		set nextpageid to item 1 of nextPageIdList
		
		set nextpageid to RemoveFromString("\"", nextpageid)
		set nextpageid to RemoveFromString(" ", nextpageid)
		set newlink to "https://explorer-api.ambrosus.com/atlases?next=" & nextpageid
		set page to page + 1
		set mJson to do shell script "curl -s " & newlink
		set AppleScript's text item delimiters to {nodeAddress}
		set keyNodeList to (every text item in mJson) as list
		set AppleScript's text item delimiters to ""
		
		set listSize to count of keyNodeList
		--display dialog ((count of keyNodeList) as string)
		if listSize is not equal to 1 then exit repeat
	end repeat
	
	-- get allbundles
	set firstSet to item 2 of keyNodeList
	set AppleScript's text item delimiters to {","}
	set keyValueList to (every text item in firstSet) as list
	set AppleScript's text item delimiters to ""
	
	set theKeyValuePair to item 9 of keyValueList
	set AppleScript's text item delimiters to {": "}
	set theKeyValueBufferList to (every text item in theKeyValuePair) as list
	set AppleScript's text item delimiters to ""
	set allbundles to item 2 of theKeyValueBufferList
	
	-- get stake
	set theKeyValuePair to item 7 of keyValueList
	set AppleScript's text item delimiters to {": "}
	set theKeyValueBufferList to (every text item in theKeyValuePair) as list
	set AppleScript's text item delimiters to ""
	set stake to item 2 of theKeyValueBufferList
	
	-- get balance
	set firstSet to item 3 of keyNodeList
	set AppleScript's text item delimiters to {","}
	set keyValueList to (every text item in firstSet) as list
	set AppleScript's text item delimiters to ""
	
	set theKeyValuePair to item 3 of keyValueList
	set AppleScript's text item delimiters to {": "}
	set theKeyValueBufferList to (every text item in theKeyValuePair) as list
	set AppleScript's text item delimiters to ""
	set balance to item 2 of theKeyValueBufferList
	
	set AppleScript's text item delimiters to "}"
	set temp to balance's text items
	set AppleScript's text item delimiters to ""
	set balance to temp as text
	
	set AppleScript's text item delimiters to "."
	set commaseperation to (every text item in balance) as list
	set AppleScript's text item delimiters to ""
	set theNumber to text item 1 of commaseperation & "," & text item 2 of commaseperation
	set balance to theNumber
	
	return {balance, stake, allbundles}
end pullAPIdataATLAS


-- remove character or string from given string
on RemoveFromString(CharOrString, txt)
	set AppleScript's text item delimiters to CharOrString
	set temp to txt's text items
	set AppleScript's text item delimiters to ""
	return temp as text
end RemoveFromString

-- change to comma
on changetocomma(txt)
	set AppleScript's text item delimiters to "."
	set commaseperation to (every text item in txt) as list
	set AppleScript's text item delimiters to ""
	set theNumber to text item 1 of commaseperation & "," & text item 2 of commaseperation
	return theNumber
end changetocomma

-- round balance to two decimals
on RoundImperialNumberToTwoDecimals(txt)
	set AppleScript's text item delimiters to ","
	if (count of text item of txt) is 2 then
		set decimals to text item 2 of txt
		if (count decimals) < 2 then
			set decimals to decimals & "0"
		end if
		set decimals to (text 1 thru 2 of decimals)
		set theNumber to text item 1 of txt & "," & decimals
		set AppleScript's text item delimiters to ""
		return theNumber
	end if
	if (count of text item of txt) is 1 then
		return txt
	end if
end RoundImperialNumberToTwoDecimals

-- convert string to numbers
on returnNumbersInString(inputString)
	set s to quoted form of inputString
	do shell script "sed s/[a-zA-Z\\']//g <<< " & s
	set dx to the result
	set numlist to {}
	repeat with i from 1 to count of words in dx
		set this_item to word i of dx
		try
			set this_item to this_item as number
			set the end of numlist to this_item
		end try
	end repeat
	return numlist
end returnNumbersInString

on number_to_string(this_number)
	set this_number to this_number as string
	if this_number contains "E+" then
		set x to the offset of "," in this_number
		set y to the offset of "+" in this_number
		set z to the offset of "E" in this_number
		set the decimal_adjust to characters (y - (length of this_number)) thru ¬
			-1 of this_number as string as number
		if x is not 0 then
			set the first_part to characters 1 thru (x - 1) of this_number as string
		else
			set the first_part to ""
		end if
		set the second_part to characters (x + 1) thru (z - 1) of this_number as string
		set the converted_number to the first_part
		repeat with i from 1 to the decimal_adjust
			try
				set the converted_number to ¬
					the converted_number & character i of the second_part
			on error
				set the converted_number to the converted_number & "0"
			end try
		end repeat
		return the converted_number
	else
		return this_number
	end if
end number_to_string

