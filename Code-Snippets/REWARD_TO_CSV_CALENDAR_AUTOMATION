-- Until we have access to detailed reward data of nodes on AMB-net from the past, 
-- this script appends your node(s) daily rewards (balance today - balance yesterday) to a csv file from the second day you run it. 
-- It checks, if data for the day has already been written to the file and doesnt do it a second time. 
-- Standard path to mining.csv and compare.txt (buffer from day before) is the Desktop.
-- Input your node Address(es), leave unused slots like they are and turn used on by setting to 1 below address input in the nodeactive variables.
-- Open this in Automator, convert it to -> Calendar Event, then save to have it in iCal, 
-- where you can set time and daily automatic execution. 
-- Adding it to iCal already executes the script. First day it just saves the compare values and on the second day it starts working accordingly.
-- If there are no rewards that day, nothing is written to the csv.
-- CAUTION !!! Always check the results, as API or other variables may change. This is NOT an official Ambrosus AMB-net tool, use at your own risk! 


-- input your Atlas node Address here:
set nodeaddress1 to "0x0000000000000000000000000000000000000000"
set nodeaddress2 to "0x0000000000000000000000000000000000000000"
set nodeaddress3 to "0x0000000000000000000000000000000000000000"
set nodeaddress4 to "0x0000000000000000000000000000000000000000"
set nodeaddress5 to "0x0000000000000000000000000000000000000000"
set nodeaddress6 to "0x0000000000000000000000000000000000000000"

-- input your Apollo node Address here:
set nodeaddress_1 to "0x0000000000000000000000000000000000000000"
set nodeaddress_2 to "0x0000000000000000000000000000000000000000"
set nodeaddress_3 to "0x0000000000000000000000000000000000000000"
set nodeaddress_4 to "0x0000000000000000000000000000000000000000"
set nodeaddress_5 to "0x0000000000000000000000000000000000000000"
set nodeaddress_6 to "0x0000000000000000000000000000000000000000"

-- set nodes to process information from !
-- ATLAS
set nodeactive1 to 0
set nodeactive2 to 0
set nodeactive3 to 0
set nodeactive4 to 0
set nodeactive5 to 0
set nodeactive6 to 0
-- APOLLO
set nodeactive_1 to 0
set nodeactive_2 to 0
set nodeactive_3 to 0
set nodeactive_4 to 0
set nodeactive_5 to 0
set nodeactive_6 to 0

---- set filepath to where the csv and buffer file are saved:
set the logFile to ((path to desktop) as text) & "mining.csv"
set the compareFile to ((path to desktop) as text) & "compare.txt"
-------------------------------------------

set balance1 to ""
set balance2 to ""
set balance3 to ""
set balance4 to ""
set balance5 to ""
set balance6 to ""
set balance_1 to ""
set balance_2 to ""
set balance_3 to ""
set balance_4 to ""
set balance_5 to ""
set balance_6 to ""

--- pull ATLAS balance from API
set balance1 to pullAPIdataATLAS(nodeactive1, nodeaddress1, balance1)
set balance2 to pullAPIdataATLAS(nodeactive2, nodeaddress2, balance2)
set balance3 to pullAPIdataATLAS(nodeactive3, nodeaddress3, balance3)
set balance4 to pullAPIdataATLAS(nodeactive4, nodeaddress4, balance4)
set balance5 to pullAPIdataATLAS(nodeactive5, nodeaddress5, balance5)
set balance6 to pullAPIdataATLAS(nodeactive6, nodeaddress6, balance6)

--- pull APOLLO balance from API
set balance_1 to pullAPIdataAPOLLO(nodeactive_1, nodeaddress_1, balance_1)
set balance_2 to pullAPIdataAPOLLO(nodeactive_2, nodeaddress_2, balance_2)
set balance_3 to pullAPIdataAPOLLO(nodeactive_3, nodeaddress_3, balance_3)
set balance_4 to pullAPIdataAPOLLO(nodeactive_4, nodeaddress_4, balance_4)
set balance_5 to pullAPIdataAPOLLO(nodeactive_5, nodeaddress_5, balance_5)
set balance_6 to pullAPIdataAPOLLO(nodeactive_6, nodeaddress_6, balance_6)


-- get date and time
set ShortDate to short date string of (current date)
set timeStr to time string of (current date)

set stampText to "20" & ((items 7 through 8 of ShortDate) as string) & "-" & ((items 4 through 5 of ShortDate) as string) & "-" & ((items 1 through 2 of ShortDate) as string)


-- check if compare.txt exists and create if not
if exists file compareFile of application "Finder" then
	set compareFileContents to (read file compareFile)
	set AppleScript's text item delimiters to ";"
	set balanceList to (every text item in compareFileContents) as list
	set AppleScript's text item delimiters to ""
else
	tell application "Finder"
		set the filePath to make new file at (path to desktop) with properties {name:"compare.txt"}
	end tell
	set fileAccess to open for access file compareFile with write permission
	if nodeactive1 is equal to 1 then write balance1 & ";" to fileAccess
	if nodeactive2 is equal to 1 then write balance2 & ";" to fileAccess
	if nodeactive3 is equal to 1 then write balance3 & ";" to fileAccess
	if nodeactive4 is equal to 1 then write balance4 & ";" to fileAccess
	if nodeactive5 is equal to 1 then write balance5 & ";" to fileAccess
	if nodeactive6 is equal to 1 then write balance6 & ";" to fileAccess
	if nodeactive_1 is equal to 1 then write balance_1 & ";" to fileAccess
	if nodeactive_2 is equal to 1 then write balance_2 & ";" to fileAccess
	if nodeactive_3 is equal to 1 then write balance_3 & ";" to fileAccess
	if nodeactive_4 is equal to 1 then write balance_4 & ";" to fileAccess
	if nodeactive_5 is equal to 1 then write balance_5 & ";" to fileAccess
	if nodeactive_6 is equal to 1 then write balance_6 & ";" to fileAccess
	close access the fileAccess
end if

-- check if mining.csv exists and create if not
if exists file logFile of application "Finder" then
	try
		set theFileContents to (read file logFile)
		set AppleScript's text item delimiters to {stampText}
		set dateList to (every text item in theFileContents) as list
		set AppleScript's text item delimiters to ""
		set listSize to count of dateList
	on error
		set listSize to 1
	end try
else
	tell application "Finder"
		set the filePath to make new file at (path to desktop) with properties {name:"mining.csv"}
		set listSize to 1
	end tell
end if

--- read yesterdays data, subtract from todays and append to csv file (only work once a day)

set compareFileContents to (read file compareFile)
set AppleScript's text item delimiters to ";"
set balanceList to (every text item in compareFileContents) as list
set AppleScript's text item delimiters to ""

set counter to 1

if listSize is 1 then
	if nodeactive1 is equal to 1 then
		set balance1 to balance1 - (item counter of balanceList)
		set counter to counter + 1
		set balance1 to number_to_string(balance1)
		set balance1 to changetodot(balance1)
		if balance1 is not equal to "0.0" then
			set nodename to "Atlas Node 1"
			write_to_file(logFile, true, balance1, stampText, timeStr, nodename)
		end if
	end if
	if nodeactive2 is equal to 1 then
		set balance2 to balance2 - (item counter of balanceList)
		set counter to counter + 1
		set balance2 to number_to_string(balance2)
		set balance2 to changetodot(balance2)
		if balance2 is not equal to "0.0" then
			set nodename to "Atlas Node 2"
			write_to_file(logFile, true, balance2, stampText, timeStr, nodename)
		end if
	end if
	if nodeactive3 is equal to 1 then
		set balance3 to balance3 - (item counter of balanceList)
		set counter to counter + 1
		set balance3 to number_to_string(balance3)
		set balance3 to changetodot(balance3)
		if balance3 is not equal to "0.0" then
			set nodename to "Atlas Node 3"
			write_to_file(logFile, true, balance3, stampText, timeStr, nodename)
		end if
	end if
	if nodeactive4 is equal to 1 then
		set balance4 to balance4 - (item counter of balanceList)
		set counter to counter + 1
		set balance4 to number_to_string(balance4)
		set balance4 to changetodot(balance4)
		if balance4 is not equal to "0.0" then
			set nodename to "Atlas Node 4"
			write_to_file(logFile, true, balance4, stampText, timeStr, nodename)
		end if
	end if
	if nodeactive5 is equal to 1 then
		set balance5 to balance5 - (item counter of balanceList)
		set counter to counter + 1
		set balance5 to number_to_string(balance5)
		set balance5 to changetodot(balance5)
		if balance5 is not equal to "0.0" then
			set nodename to "Atlas Node 5"
			write_to_file(logFile, true, balance5, stampText, timeStr, nodename)
		end if
	end if
	if nodeactive6 is equal to 1 then
		set balance6 to balance6 - (item counter of balanceList)
		set counter to counter + 1
		set balance6 to number_to_string(balance6)
		set balance6 to changetodot(balance6)
		if balance6 is not equal to "0.0" then
			set nodename to "Atlas Node 6"
			write_to_file(logFile, true, balance6, stampText, timeStr, nodename)
		end if
	end if
	if nodeactive_1 is equal to 1 then
		set balance_1 to balance_1 - (item counter of balanceList)
		set counter to counter + 1
		set balance_1 to number_to_string(balance_1)
		set balance_1 to changetodot(balance_1)
		if balance_1 is not equal to "0.0" then
			set nodename to "Apollo Node 1"
			write_to_file(logFile, true, balance_1, stampText, timeStr, nodename)
		end if
	end if
	if nodeactive_2 is equal to 1 then
		set balance_2 to balance_2 - (item counter of balanceList)
		set counter to counter + 1
		set balance_2 to number_to_string(balance_2)
		set balance_2 to changetodot(balance_2)
		if balance_2 is not equal to "0.0" then
			set nodename to "Apollo Node 2"
			write_to_file(logFile, true, balance_2, stampText, timeStr, nodename)
		end if
	end if
	if nodeactive_3 is equal to 1 then
		set balance_3 to balance_3 - (item counter of balanceList)
		set counter to counter + 1
		set balance_3 to number_to_string(balance_3)
		set balance_3 to changetodot(balance_3)
		if balance_3 is not equal to "0.0" then
			set nodename to "Apollo Node 3"
			write_to_file(logFile, true, balance_3, stampText, timeStr, nodename)
		end if
	end if
	if nodeactive_4 is equal to 1 then
		set balance_4 to balance_4 - (item counter of balanceList)
		set counter to counter + 1
		set balance_4 to number_to_string(balance_4)
		set balance_4 to changetodot(balance_4)
		if balance_4 is not equal to "0.0" then
			set nodename to "Apollo Node 4"
			write_to_file(logFile, true, balance_4, stampText, timeStr, nodename)
		end if
	end if
	if nodeactive_5 is equal to 1 then
		set balance_5 to balance_5 - (item counter of balanceList)
		set counter to counter + 1
		set balance_5 to number_to_string(balance_5)
		set balance_5 to changetodot(balance_5)
		if balance_5 is not equal to "0.0" then
			set nodename to "Apollo Node 5"
			write_to_file(logFile, true, balance_5, stampText, timeStr, nodename)
		end if
	end if
	if nodeactive_6 is equal to 1 then
		set balance_6 to balance_6 - (item counter of balanceList)
		set counter to counter + 1
		set balance_6 to number_to_string(balance_6)
		set balance_6 to changetodot(balance_6)
		if balance_6 is not equal to "0.0" then
			set nodename to "Apollo Node 6"
			write_to_file(logFile, true, balance_6, stampText, timeStr, nodename)
		end if
	end if
end if



------- functions below -----------------------

--- change csv syntax here:

on write_to_file(target_file, append_data, balance, todaysDate, todaysTime, nodes)
	try
		set this_data to "
\"" & "Mining\"" & ",\"" & balance & "\",\"" & "AMB" & "\",\"\"" & ",\"\"" & ",\"\"" & ",\"\"" & ",\"\"" & ",\"\"" & ",\"" & nodes & "\",\"" & todaysDate & " " & todaysTime & "\""
		set the target_file to the target_file as text
		set the open_target_file to ¬
			open for access file target_file with write permission
		if append_data is false then ¬
			set eof of the open_target_file to 0
		write this_data to the open_target_file starting at eof
		close access the open_target_file
		return true
	on error
		try
			close access file target_file
		end try
		return false
	end try
end write_to_file

---- pull api data ATLAS
on pullAPIdataATLAS(nodeactive, nodeAddress, balance)
	if nodeactive is equal to 1 then
		-- get info around particular Atlas node 1
		set mJson to do shell script "curl -s 'https://explorer-api.ambrosus.com/atlases'"
		set AppleScript's text item delimiters to {nodeAddress}
		set keyNodeList to (every text item in mJson) as list
		set AppleScript's text item delimiters to ""
		
		set listSize to count of keyNodeList
		set page to 1
		-- iterate through pages of 50 nodes to find the right one
		repeat while listSize = 1
			set AppleScript's text item delimiters to {"\"next\":"}
			set keyNodeList to (every text item in mJson) as list
			set AppleScript's text item delimiters to ""
			set pageEnd to item 2 of keyNodeList
			
			set AppleScript's text item delimiters to {","}
			set nextPageIdList to (every text item in pageEnd) as list
			set AppleScript's text item delimiters to ""
			set nextpageid to item 1 of nextPageIdList
			
			set nextpageid to RemoveFromString("\"", nextpageid)
			set nextpageid to RemoveFromString(" ", nextpageid)
			set newlink to "https://explorer-api.ambrosus.com/atlases?next=" & nextpageid
			set page to page + 1
			set mJson to do shell script "curl -s " & newlink
			set AppleScript's text item delimiters to {nodeAddress}
			set keyNodeList to (every text item in mJson) as list
			set AppleScript's text item delimiters to ""
			
			set listSize to count of keyNodeList
			--display dialog ((count of keyNodeList) as string)
			if listSize is not equal to 1 then exit repeat
		end repeat
		
		-- get balance
		set firstSet to item 3 of keyNodeList
		set AppleScript's text item delimiters to {","}
		set keyValueList to (every text item in firstSet) as list
		set AppleScript's text item delimiters to ""
		
		set theKeyValuePair to item 3 of keyValueList
		set AppleScript's text item delimiters to {": "}
		set theKeyValueBufferList to (every text item in theKeyValuePair) as list
		set AppleScript's text item delimiters to ""
		set balance to item 2 of theKeyValueBufferList
		
		set AppleScript's text item delimiters to "}"
		set temp to balance's text items
		set AppleScript's text item delimiters to ""
		set balance to temp as text
		
		set AppleScript's text item delimiters to "."
		set commaseperation to (every text item in balance) as list
		set AppleScript's text item delimiters to ""
		set theNumber to text item 1 of commaseperation & "," & text item 2 of commaseperation
		set balance to theNumber
		
		return balance
	end if
end pullAPIdataATLAS

---- pull api data APOLLO
on pullAPIdataAPOLLO(nodeactive, nodeAddress, balance)
	if nodeactive is equal to 1 then
		-- get info around particular Apollo node 1
		set mJson to do shell script "curl -s 'https://explorer-api.ambrosus.com/apollos'"
		set AppleScript's text item delimiters to {nodeAddress}
		set keyNodeList to (every text item in mJson) as list
		set AppleScript's text item delimiters to ""
		
		set listSize to count of keyNodeList
		set page to 1
		-- iterate through pages of 50 nodes to find the right one
		repeat while listSize = 1
			set AppleScript's text item delimiters to {"\"next\":"}
			set keyNodeList to (every text item in mJson) as list
			set AppleScript's text item delimiters to ""
			set pageEnd to item 2 of keyNodeList
			
			set AppleScript's text item delimiters to {","}
			set nextPageIdList to (every text item in pageEnd) as list
			set AppleScript's text item delimiters to ""
			set nextpageid to item 1 of nextPageIdList
			
			set nextpageid to RemoveFromString("\"", nextpageid)
			set nextpageid to RemoveFromString(" ", nextpageid)
			set newlink to "https://explorer-api.ambrosus.com/apollos?next=" & nextpageid
			set page to page + 1
			set mJson to do shell script "curl -s " & newlink
			set AppleScript's text item delimiters to {nodeAddress}
			set keyNodeList to (every text item in mJson) as list
			set AppleScript's text item delimiters to ""
			
			set listSize to count of keyNodeList
			--display dialog ((count of keyNodeList) as string)
			if listSize is not equal to 1 then exit repeat
		end repeat
		
		
		-- get status
		set firstSet to item 2 of keyNodeList
		set AppleScript's text item delimiters to {","}
		set keyValueList to (every text item in firstSet) as list
		set AppleScript's text item delimiters to ""
		
		set theKeyValuePair to item 4 of keyValueList
		set AppleScript's text item delimiters to {": "}
		set theKeyValueBufferList to (every text item in theKeyValuePair) as list
		set AppleScript's text item delimiters to ""
		set status to item 2 of theKeyValueBufferList
		set status to RemoveFromString("\"", status)
		
		if status is equal to "ONLINE" then
			-- get balance
			set firstSet to item 3 of keyNodeList
			set AppleScript's text item delimiters to {","}
			set keyValueList to (every text item in firstSet) as list
			set AppleScript's text item delimiters to ""
			
			set theKeyValuePair to item 3 of keyValueList
			set AppleScript's text item delimiters to {": "}
			set theKeyValueBufferList to (every text item in theKeyValuePair) as list
			set AppleScript's text item delimiters to ""
			set balance to item 2 of theKeyValueBufferList
		end if
		
		if status is not equal to "ONLINE" then
			-- get balance
			set firstSet to item 3 of keyNodeList
			set AppleScript's text item delimiters to {","}
			set keyValueList to (every text item in firstSet) as list
			set AppleScript's text item delimiters to ""
			
			set theKeyValuePair to item 3 of keyValueList
			set AppleScript's text item delimiters to {": "}
			set theKeyValueBufferList to (every text item in theKeyValuePair) as list
			set AppleScript's text item delimiters to ""
			set balance to item 2 of theKeyValueBufferList
		end if
		
		set AppleScript's text item delimiters to "\""
		set temp to balance's text items
		set AppleScript's text item delimiters to ""
		set balance to temp as text
		
		set AppleScript's text item delimiters to "}"
		set temp to balance's text items
		set AppleScript's text item delimiters to ""
		set balance to temp as text
		
		set AppleScript's text item delimiters to "."
		set commaseperation to (every text item in balance) as list
		set AppleScript's text item delimiters to ""
		set theNumber to text item 1 of commaseperation & "," & text item 2 of commaseperation
		set balance to theNumber
		
	end if
end pullAPIdataAPOLLO


-- remove character or string from given string
on RemoveFromString(CharOrString, txt)
	set AppleScript's text item delimiters to CharOrString
	set temp to txt's text items
	set AppleScript's text item delimiters to ""
	return temp as text
end RemoveFromString

-- change to comma
on changetocomma(txt)
	set AppleScript's text item delimiters to "."
	set commaseperation to (every text item in txt) as list
	set AppleScript's text item delimiters to ""
	set theNumber to text item 1 of commaseperation & "," & text item 2 of commaseperation
	return theNumber
end changetocomma

-- change to dot
on changetodot(txt)
	set AppleScript's text item delimiters to ","
	set commaseperation to (every text item in txt) as list
	set AppleScript's text item delimiters to ""
	set theNumber to text item 1 of commaseperation & "." & text item 2 of commaseperation
	return theNumber
end changetodot

-- round balance to two decimals
on RoundImperialNumberToTwoDecimals(txt)
	set AppleScript's text item delimiters to ","
	if (count of text item of txt) is 2 then
		set decimals to text item 2 of txt
		if (count decimals) < 2 then
			set decimals to decimals & "0"
		end if
		set decimals to (text 1 thru 2 of decimals)
		set theNumber to text item 1 of txt & "," & decimals
		set AppleScript's text item delimiters to ""
		return theNumber
	end if
	if (count of text item of txt) is 1 then
		return txt
	end if
end RoundImperialNumberToTwoDecimals

-- convert string to numbers
on returnNumbersInString(inputString)
	set s to quoted form of inputString
	do shell script "sed s/[a-zA-Z\\']//g <<< " & s
	set dx to the result
	set numlist to {}
	repeat with i from 1 to count of words in dx
		set this_item to word i of dx
		try
			set this_item to this_item as number
			set the end of numlist to this_item
		end try
	end repeat
	return numlist
end returnNumbersInString

on number_to_string(this_number)
	set this_number to this_number as string
	if this_number contains "E+" then
		set x to the offset of "," in this_number
		set y to the offset of "+" in this_number
		set z to the offset of "E" in this_number
		set the decimal_adjust to characters (y - (length of this_number)) thru ¬
			-1 of this_number as string as number
		if x is not 0 then
			set the first_part to characters 1 thru (x - 1) of this_number as string
		else
			set the first_part to ""
		end if
		set the second_part to characters (x + 1) thru (z - 1) of this_number as string
		set the converted_number to the first_part
		repeat with i from 1 to the decimal_adjust
			try
				set the converted_number to ¬
					the converted_number & character i of the second_part
			on error
				set the converted_number to the converted_number & "0"
			end try
		end repeat
		return the converted_number
	else
		return this_number
	end if
end number_to_string

